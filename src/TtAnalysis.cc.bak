// -*- C++ -*-
//
// Package:    TtAnalysis
// Class:      TtAnalysis
// 
/**\class TtAnalysis TtAnalysis.cc PhysicsTools/TtAnalysis/src/TtAnalysis.cc

 Description: <one line class summary>

 Implementation:
     <Notes on implementation>
*/
//
// Original Author:  Shih-Chuan Kao
//         Created:  Fri May 16 2008
//
//


// system include files
#include <memory>

// user include files
#include "TtAnalysis.h"
#include "TtEvtSelector.h"
#include "FWCore/Framework/interface/MakerMacros.h"
//#include "FWCore/Framework/interface/Frameworkfwd.h"
//#include "FWCore/Framework/interface/EDAnalyzer.h"

//#include "FWCore/Framework/interface/Event.h"

//#include "FWCore/ParameterSet/interface/ParameterSet.h"

//
// constants, enums and typedefs
//

//
// static data member definitions
//


// constructors and destructor
using namespace edm;
using namespace std;
TtAnalysis::TtAnalysis(const edm::ParameterSet& iConfig)
{
  //now do what ever initialization is needed
  debug             = iConfig.getUntrackedParameter<bool>   ("debug");
  rootFileName      = iConfig.getUntrackedParameter<string> ("rootFileName");
  leptonFlavour     = iConfig.getParameter<std::string>   ("leptonFlavour");
  muonSrc           = iConfig.getParameter<edm::InputTag> ("muonSource");
  electronSrc       = iConfig.getParameter<edm::InputTag> ("electronSource");
  photonSrc         = iConfig.getParameter<edm::InputTag> ("photonSource");
  metSrc            = iConfig.getParameter<edm::InputTag> ("metSource");
  jetSrc            = iConfig.getParameter<edm::InputTag> ("jetSource");
  genSrc            = iConfig.getParameter<edm::InputTag> ("genParticles"); 
  recoMuon          = iConfig.getUntrackedParameter<string> ("recoMuons");
  caloSrc           = iConfig.getParameter<edm::InputTag> ("caloSource"); 
 
  //recoJet           = iConfig.getUntrackedParameter<string> ("recoJets");

  evtSelected = new TtEvtSelector();
  MCMatching  = new TtMCMatching();
  evtIt = 0;
  // Create the root file
  theFile = new TFile(rootFileName.c_str(), "RECREATE");

  theFile->mkdir("Jets");
  theFile->cd();
  theFile->mkdir("METs");
  theFile->cd();
  theFile->mkdir("Leps");
  theFile->cd();
  theFile->mkdir("Tops");
  theFile->cd();
  theFile->mkdir("WJets");
  theFile->cd();
  theFile->mkdir("MJets");
  theFile->cd();

  h_Jet   = new HTOP1("Jets_");
  h_MET   = new HTOP2("MET_");
  h_Lep   = new HTOP3("Leps_");
  h_Top   = new HTOP4("Tops_");
  h_WJet   = new HTOP5("MJets_");
  h_MJet   = new HTOP6("WJets_");

  t_Jet  = new NJet();
}


TtAnalysis::~TtAnalysis()
{
 
   // do anything here that needs to be done at desctruction time
   // (e.g. close files, deallocate resources etc.)
   if (debug) cout << "[TtAnalysis Analysis] Destructor called" << endl;

   delete evtSelected;
   delete MCMatching;

   //theFile->cd();
   t_Jet->Write();

   theFile->cd();
   theFile->cd("Jets");
   h_Jet->Write();

   theFile->cd();
   theFile->cd("METs");
   h_MET->Write();

   theFile->cd();
   theFile->cd("Leps");
   h_Lep->Write();

   theFile->cd();
   theFile->cd("Tops");
   h_Top->Write();

   theFile->cd();
   theFile->cd("WJets");
   h_WJet->Write();

   theFile->cd();
   theFile->cd("MJets");
   h_MJet->Write();

   //Release the memory
   delete h_Jet;
   delete h_MET;
   delete h_Lep;
   delete h_Top;
   delete h_WJet;
   delete h_MJet;
  
   delete t_Jet;

   //Close the Root file
   theFile->Close();
   if (debug) cout << "************* Finished writing histograms to file" << endl;

}

//
// member functions
//

// ------------ method called to for each event  ------------
void TtAnalysis::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
{

   // retrieve the reco-objects
   
   Handle<std::vector<pat::Muon> > muons;
   iEvent.getByLabel(muonSrc, muons);

   Handle<std::vector<reco::Muon> > recomuons;
   if ( recoMuon == "paramMuons" ) {
      iEvent.getByLabel(recoMuon,"ParamGlobalMuons",recomuons);
   }
   if ( recoMuon == "muons" ) {
      iEvent.getByLabel(recoMuon,"",recomuons);
   }

   Handle<std::vector<pat::Electron> > electrons;
   iEvent.getByLabel(electronSrc, electrons);

   Handle<std::vector<pat::Photon> > photons;
   iEvent.getByLabel(photonSrc, photons);

   Handle<std::vector<pat::MET> > mets;
   iEvent.getByLabel(metSrc, mets);

   Handle<std::vector<pat::Jet> > jets;
   iEvent.getByLabel(jetSrc, jets);

   Handle<std::vector<reco::GenParticle> > genParticles;
   iEvent.getByLabel(genSrc, genParticles);

   Handle<CaloTowerCollection>  caloTowers;
   iEvent.getByLabel(caloSrc, caloTowers);

   // Initial the histograms
   HTOP1 *histo1 = 0;
   HTOP2 *histo2 = 0;
   HTOP3 *histo3 = 0;
   HTOP4 *histo4 = 0;
   HTOP5 *histo5 = 0;
   HTOP6 *histo6 = 0;
   NJet  *jtree = 0;

   cout<<" ***** new Event start ***** "<<endl;

   // 0. select the semi-lep events and objects
   bool pass = evtSelected->eventSelection(muons, electrons, jets);
   int  topo = evtSelected->MCEvtSelection(genParticles);
   std::vector<pat::Jet> wjets = evtSelected->WJetSelection(jets);
   //std::vector<pat::Muon> selectedMuons = evtSelected->MuonSelection(muons);

   evtIt++;
   int eventId = evtIt + (iEvent.id().run()*100000) ;
   // 1. Jet Sector
   histo1 = h_Jet;
   /// 1a) overall jet information
   int nJets = jets->size();
   int nj[3] = {0};
   jtree = t_Jet;
   for (std::vector<pat::Jet>::const_iterator j1 = jets->begin(); j1 != jets->end(); j1++)
   {
 
       float emE0 = (*j1).emEnergyInEB() + (*j1).emEnergyInEE() + (*j1).emEnergyInHF() ;
       float hdE0 = (*j1).hadEnergyInHB() +(*j1).hadEnergyInHE() + (*j1).hadEnergyInHF() + (*j1).hadEnergyInHO();
       double totalE = emE0 +hdE0 ;
       float emF0 = emE0 /totalE ;
       float emF  = (*j1).emEnergyFraction() ;
 
       double EovH = EoverH(*j1);
     
       int nCon = (*j1).nConstituents();
       double rCon = NofJetConstituents( *j1 ) ;
       edm::RefVector<reco::TrackCollection>  assTk = (*j1).associatedTracks() ;

       histo1->Fill1a( (*j1).pt(), (*j1).et(), (*j1).eta(), EovH, nCon,(*j1).n60()/nCon, (*j1).n90()/nCon, (*j1).pt(), rCon, (*j1).towersArea(), assTk.size(), emF, emF0);

 
       if ( (*j1).pt() > 20.0  ) {
          histo1->Fill1h( EovH, (*j1).eta(), (*j1).towersArea(), nCon, assTk.size() ,rCon, (*j1).n60()/nCon );
          if ( assTk.size() > 0) {
	     jtree->FillBpatJ( eventId, j1->eta(), j1->phi(), emE0, hdE0, j1->p(), j1->pt() );
          }
       }

       if ( (*j1).pt() > 20. && fabs((*j1).eta()) < 2.0) nj[0]++;
       if ( (*j1).pt() > 30. && fabs((*j1).eta()) < 2.0) nj[1]++;
       if ( (*j1).pt() > 40. && fabs((*j1).eta()) < 2.0) nj[2]++;
   }
   histo1->Fill1f( nJets, nj[0], nj[1], nj[2] );   

   /// 1b) gen-reco matching 
   //matchJet(genParticles,jets);
   std::vector<jmatch> mcwjets = MCMatching->matchWJets(genParticles, jets);

   histo6 = h_MJet;
   
   LorentzVector qm[4] ;
   for (std::vector<jmatch>::const_iterator j1 = mcwjets.begin(); j1 != mcwjets.end(); j1++) {

       if ( (*j1).MomIdx == 1 )  qm[0] = (*j1).sumP4 ;
       if ( (*j1).MomIdx == 2 )  qm[1] = (*j1).sumP4 ;
       if ( (*j1).MomIdx == 3 )  qm[2] = (*j1).sumP4 ;
       if ( (*j1).MomIdx == 4 )  qm[3] = (*j1).sumP4 ;
       
   }

   if (qm[0].E() != 0 && qm[1].E() != 0 ) {
      LorentzVector pW = findW( qm[0], qm[1]);
      double momW = sqrt( pW.Px()*pW.Px() + pW.Py()*pW.Py() + pW.Pz()*pW.Pz() );
      double massW = sqrt ( pW.E()*pW.E() - pW.Px()*pW.Px() - pW.Py()*pW.Py() - pW.Pz()*pW.Pz() );

      histo6->Fill6b( massW, momW );
   }
   if (qm[2].E() != 0 && qm[3].E() != 0 ) {
      LorentzVector pW = findW( qm[2], qm[3]);
      double momW = sqrt( pW.Px()*pW.Px() + pW.Py()*pW.Py() + pW.Pz()*pW.Pz() );
      double massW = sqrt ( pW.E()*pW.E() - pW.Px()*pW.Px() - pW.Py()*pW.Py() - pW.Pz()*pW.Pz() );

      histo6->Fill6b( massW, momW );
   }

   // look at matched jet properties
   for (std::vector<jmatch>::const_iterator j1 = mcwjets.begin(); j1 != mcwjets.end(); j1++) {

       pat::Jet leader =  (*j1).leadingJet ; 
       reco::Particle jmom = j1->mom;

       int    nCon = leader.nConstituents();
       double EovH = EoverH( leader  );
       double rCon = NofJetConstituents( leader ) ;
       edm::RefVector<reco::TrackCollection>  assTk = leader.associatedTracks() ;

       histo6->Fill6a( leader.pt(), leader.eta(), EovH, nCon, leader.n60()/nCon, leader.n90()/nCon, rCon , leader.towersArea(), assTk.size(), leader.emEnergyFraction() );
       histo1->Fill1c( jmom.pt(), jmom.eta() );
       histo1->Fill1j( (*j1).res_P );

   } 

   // look at the W for qq 
   for (std::vector<reco::GenParticle>::const_iterator it = genParticles->begin(); it != genParticles->end(); it++ ){
       if ( abs((*it).pdgId()) != 24) continue;
       bool WfromT = false;
       for (size_t q=0; q< (*it).numberOfMothers(); q++) {
           const reco::Candidate *mom = (*it).mother(q) ;
           if ( abs(mom->pdgId()) != 6 ) continue;
           WfromT = true ;
       }
       if ( !WfromT ) continue;

       std::vector<LorentzVector> qm ;
       for (size_t q=0; q< (*it).numberOfDaughters(); ++q) {
           const reco::Candidate *dau = (*it).daughter(q) ;
           if( abs(dau->pdgId()) > 6 ) continue;
           qm.push_back( dau->p4() );
	   jtree->FillBgen( eventId, dau->pdgId(), dau->eta(), dau->phi(), dau->energy(), dau->pt() );
           cout<<"quarks:"<<dau->pdgId() <<" h: "<<dau->eta()<<" f:"<<dau->phi()<<" It:"<<eventId;
           cout<<" E:"<<dau->energy()<< endl;
       }
       if ( qm.size() == 2 ) {
          LorentzVector pW = findW( qm[0], qm[1]);
	  double momW = sqrt( pW.Px()*pW.Px() + pW.Py()*pW.Py() + pW.Pz()*pW.Pz() );
	  double massW = sqrt ( pW.E()*pW.E() - pW.Px()*pW.Px() - pW.Py()*pW.Py() - pW.Pz()*pW.Pz() );
	  histo1->Fill1g( massW, momW );
       }
   }
   cout<<" "<<endl;
   cout<<"  ^^^^^^^ end of w reco ^^^^^^^^ "<<endl;

   // jets selection
   double jPt[2]  = {0.0, 0.0};
   double jPhi[2] = {-9.0, -9.0};
   double jEta[2] = {-9.0, -9.0};
  
   histo5 = h_WJet;
   int idx=0;
   for (std::vector<pat::Jet>::const_iterator j1 = wjets.begin(); j1 != wjets.end(); j1++)
   {
       if ( idx < 2){
          jPt[idx] = j1->pt() ;
          jPhi[idx] = j1->phi() ;
          jEta[idx] = j1->eta() ;
       }
       idx++;
   }
   histo5->Fill5a( jPt[0], jPt[1], jEta[0], jEta[1], wjets.size() );

   // rebuild W from selected jets!
   int jj1 =0;
   for (std::vector<pat::Jet>::const_iterator j1 = wjets.begin(); j1 != wjets.end(); j1++)
   {
       // only semi-lep 
       if ( topo != 1 || !pass ) continue;

       jj1++ ;
       int jj2 =0;

       double EovH1 = EoverH(*j1) ;
       if ((*j1).nConstituents() < 5 || EovH1 > 20 || EovH1 < 0.01) continue;
       if ((*j1).towersArea()/(*j1).pt() > 0.005 ) continue;

       for (std::vector<pat::Jet>::const_iterator j2 = wjets.begin(); j2 != wjets.end(); j2++)
       {
           jj2++;
           if (j2 <= j1) continue;

           double EovH2 = EoverH(*j2) ;

           if ((*j2).nConstituents() < 5 || EovH2 > 20 || EovH2 < 0.01) continue;
           if ((*j2).towersArea()/(*j2).pt() > 0.005 ) continue;
           //cout<<" flavor1: "<< (*j1).partonFlavour()<<"  vtx:"<<(*j1).vertex() <<endl; 
           //cout<<" flavor2: "<< (*j2).partonFlavour()<<"  vtx:"<<(*j2).vertex() <<endl;
           //LorentzVector qm1 = (*j1).energyFractionHadronic() * (*j1).p4();
           //LorentzVector qm2 = (*j2).energyFractionHadronic() * (*j2).p4();
           LorentzVector qm1 = (*j1).p4();
           LorentzVector qm2 = (*j2).p4();
           LorentzVector pW = findW( qm1, qm2);
           double momW = sqrt( pW.Px()*pW.Px() + pW.Py()*pW.Py() + pW.Pz()*pW.Pz() );
           double massW = sqrt ( pW.E()*pW.E() - pW.Px()*pW.Px() - pW.Py()*pW.Py() - pW.Pz()*pW.Pz() );     
           //cout<<" combination of "<<jj1<<" & "<<jj2<<endl;
           //cout<<" find W = "<< pW.Px() <<","<< pW.Py() <<","<< pW.Pz() <<","<< pW.P() <<endl;
           //cout<<" mass W = "<< massW <<endl;
           //if (!exclude) {
           histo5->Fill5b( massW, momW );
           //}
       }
   }

   // crapy jet scope
   for (std::vector<pat::Jet>::const_iterator j1 = jets->begin(); j1 != jets->end(); j1++)
   {
       if ((*j1).towersArea()/(*j1).pt() < 0.005 ) continue;
       double EovH = EoverH(*j1);
       int    nCon = (*j1).nConstituents();
       double rCon = NofJetConstituents( *j1 ) ;
       edm::RefVector<reco::TrackCollection>  assTk = (*j1).associatedTracks() ;

       histo1->Fill1i( (*j1).eta(), EovH, nCon, assTk.size(), (*j1).n60()/nCon, (*j1).n90()/nCon, rCon );

   }
   
   // MET from PAT
   histo2 = h_MET;
   for (std::vector<pat::MET>::const_iterator m1 = mets->begin(); m1 != mets->end(); m1++)
   {
       float emMET = (*m1).emEtInEB()  + (*m1).emEtInEE()  + (*m1).emEtInHF() ;
       float hdMET = (*m1).hadEtInHB() + (*m1).hadEtInHE() + (*m1).hadEtInHF() + (*m1).hadEtInHO() ;
       float emfCalo = 1. - (emMET/(emMET + hdMET)) ;
  
       float emf = (*m1).emEtFraction() ;
       //float hdf = (*m1).etFractionHadronic() ;
       jtree->FillBpatNu( eventId, m1->eta(), m1->phi(), emMET, hdMET, m1->p(), m1->pt() );
       histo2->Fill2a( (*m1).et(), emf, emfCalo, (*m1).sumEt() );

       // calculate the MET from Calo
       std::vector<double> calo = CaloMET(caloTowers);
       // calculate the muon correction
       std::vector<double> muPtCorr = MuonEtCorrection(muons);

       double calx = calo[0] + muPtCorr[0];
       double caly = calo[1] + muPtCorr[1];
       double vsc =  sqrt( calx*calx + caly*caly );
       double phic = atan2(-1.*caly, -1.*calx);

       double calx1 = calo[0] + muPtCorr[2];
       double caly1 = calo[1] + muPtCorr[3];
       double vsc1  =  sqrt( calx1*calx1 + caly1*caly1 );
       double phic1 = atan2(-1.*caly1, -1*calx1);

       // find neutrino from generator
       LorentzVector vP4 = findNeutrino(genParticles) ;

       double vPT = sqrt(vP4.Px()*vP4.Px() + vP4.Py()*vP4.Py());
       double vPhi= atan2(vP4.Py(), vP4.Px());


       double MET_Res[3] = {100.0, 100.0, 100.0};
       double Phi_Res[3] = {100.0, 100.0, 100.0};

       if ( vPT != 0 ) {
          MET_Res[0] = ((*m1).et() - vPT) / vPT ;
	  MET_Res[1] = ( vsc - vPT) / vPT ;
	  MET_Res[2] = ( vsc1 - vPT) / vPT ;

	  Phi_Res[0] = (*m1).phi() - vPhi;
	  Phi_Res[1] =  phic  - vPhi;
	  Phi_Res[2] =  phic1 - vPhi;
       }
       histo2->Fill2b( MET_Res[0],MET_Res[1],MET_Res[2],Phi_Res[0],Phi_Res[1],Phi_Res[2] );

   }
   //for (std::vector<pat::Muon>::const_iterator it = selectedMuons.begin(); it!= selectedMuons.end(); it++) {
   for (std::vector<pat::Muon>::const_iterator it = muons->begin(); it!= muons->end(); it++) {

       reco::MuonEnergy CaloE = it->getCalEnergy();
       double emE = CaloE.em;
       double hdE = CaloE.had;
       jtree->FillBpatMu( eventId, it->eta(), it->phi(), emE, hdE, it->p(), it->pt() );
       
   }
   for (std::vector<pat::Electron>::const_iterator it = electrons->begin(); it != electrons->end(); it++ ) {
       //reco::PixelMatchGsfElectron CaloE = it->caloEnergy() ;
       double AllCaloE = it->caloEnergy() ;
       //double AllCaloE = CaloE.caloEnergy() ;
       double HovE = it->hadronicOverEm() ;
       double emF = 1.0 /(HovE + 1.0) ;
       double emE = AllCaloE * emF ;
       double hdE = AllCaloE * (1.0-emF);
       jtree->FillBpatE( eventId, it->eta(), it->phi(), emE, hdE, it->p(), it->pt() );
   }
   for (std::vector<pat::Photon>::const_iterator it = photons->begin(); it != photons->end(); it++ ) {
       jtree->FillBpatGa( eventId, it->eta(), it->phi(), it->energy() , 0., it->p(), it->pt() );
   }
   // Muon stuff
   std::vector<hfPos> mpa; 
   for (std::vector<reco::GenParticle>::const_iterator it = genParticles->begin(); it != genParticles->end(); it++ ){
       // categorize the muons
       if ( !pass ) continue;
       if ( abs((*it).pdgId()) != 13) continue; 

       for (size_t j=0; j< (*it).numberOfMothers(); ++j) {

           const reco::Candidate *mom = (*it).mother(j);
               
              // avoid double couting the muons in different status
              if ( mom->pdgId() == (*it).pdgId() ) continue;

               hfPos mpos(4);
               mpos[0] = (*it).eta() ;
               mpos[1] = (*it).phi() ;
               mpos[2] = (*it).pt() ;
               mpos[3] =  -1 ;        // initialized the type of muon 
              // 1. signal and signal like
              if ( abs(mom->pdgId()) == 24 || abs(mom->pdgId()) == 23 ) {

		 //cout<<" *1* signal  mom:"<<mom->pdgId()<<endl;;
                 // signal(from t->w ) or signal like(for w/Z )  
                 std::vector<int> gma = findGrandMa( mom->pdgId(), mom->eta(), mom->phi(), genParticles ) ;

                 bool tquarkmom = false;
                 for (std::vector<int>::iterator it1 = gma.begin(); it1 != gma.end(); it1++){
                     if (abs(*it1) == 6) tquarkmom = true;
                 }

                 if ( (*it).status() == 1 ) {
                     if ( tquarkmom ) {
                          mpos[3] = 0;
                          mpa.push_back( mpos );
                          //cout<<" set type => "<<mpos[3]<<endl; 
        	          //cout<<" h:"<<mpos[0]<<" f:"<<mpos[1]<<" pt:"<<mpos[2]<<endl;
                     }
                     else{ 
                          mpos[3] = 1;
                          mpa.push_back( mpos ); 
                          //cout<<" set type => "<<mpos[3]<<endl; 
        	          //cout<<" h:"<<mpos[0]<<" f:"<<mpos[1]<<" pt:"<<mpos[2]<<endl;
                     }
                 } else {
                       hfPos dau = findDaughter( (*it).pdgId(), (*it).pdgId(), (*it).eta(), (*it).phi()
                                             , genParticles);
                       if ( tquarkmom ) { 
                          dau[3] = 0;
                          mpa.push_back( dau ); 
                          //cout<<" set type -> "<<dau[3]<<endl; 
                          //cout<<" h:"<<dau[0]<<" f:"<<dau[1]<<" pt:"<<dau[2]<<endl;
                       }
                       else{          
                          dau[3] = 1;
                          mpa.push_back( dau ); 
                          //cout<<" set type -> "<<dau[3]<<endl; 
                          //cout<<" h:"<<dau[0]<<" f:"<<dau[1]<<" pt:"<<dau[2]<<endl;
                       }
                 }
              }
              // 2. heavy flavour ( charm & bottom mesons ) 
              else if( abs(mom->pdgId())%1000 > 400 && abs(mom->pdgId())%1000 < 600 ) {
                     //cout<<" *2* heavy flavor  mom:"<<mom->pdgId()<<endl;
                     if ( (*it).status() == 1 ) {
                        mpos[3] = 2;
                        mpa.push_back( mpos ); 
                        //cout<<" set type => "<<mpos[3]<<endl; 
                        //cout<<" h:"<<mpos[0]<<" f:"<<mpos[1]<<" pt:"<<mpos[2]<<endl;
                     } else {
                        hfPos dau = findDaughter( (*it).pdgId(), (*it).pdgId(),
                                                               (*it).eta(), (*it).phi(), genParticles);
                        dau[3] = 2;
                        mpa.push_back( dau ); 
                        //cout<<" set type -> "<<dau[3]<<endl; 
                        //cout<<" h:"<<dau[0]<<" f:"<<dau[1]<<" pt:"<<dau[2]<<endl;

                     }
              } 
              // 3. decay in fly 
              else if( abs(mom->pdgId())%1000 < 400 && abs(mom->pdgId())%1000 > 100) {
                     //cout<<" *3* decay in fly  mom:"<<mom->pdgId()<<endl;
                     if ( (*it).status() == 1 ) {
                        mpos[3] = 3;
                        mpa.push_back( mpos ); 
                        //cout<<" set type => "<<mpos[3]<<endl; 
                        //cout<<" h:"<<mpos[0]<<" f:"<<mpos[1]<<" pt:"<<mpos[2]<<endl;
                     } else {
                        hfPos dau = findDaughter( (*it).pdgId(), (*it).pdgId(),
                                                               (*it).eta(), (*it).phi(), genParticles);
                        dau[3] = 3;
                        mpa.push_back( dau ); 
                        //cout<<" set type -> "<<dau[3]<<endl; 
                        //cout<<" h:"<<dau[0]<<" f:"<<dau[1]<<" pt:"<<dau[2]<<endl;
                     }
              }// 4. other source ; most of them are coming from tau
              else {
                     //cout<<" *4* other source  mom:"<<mom->pdgId()<<endl;
                     if ( (*it).status() == 1 ) {
                        mpos[3] = 4;
                        mpa.push_back( mpos ); 
                        //cout<<"set type => "<<mpos[3]<<endl; 
                        //cout<<" h:"<<mpos[0]<<" f:"<<mpos[1]<<" pt:"<<mpos[2]<<endl;
                     } else {
                        hfPos dau = findDaughter( (*it).pdgId(), (*it).pdgId(),
                                                               (*it).eta(), (*it).phi(), genParticles);
                        dau[3] = 4;
                        mpa.push_back( dau ); 
                        //cout<<"set type -> "<<dau[3]<<endl; 
                        //cout<<" h:"<<dau[0]<<" f:"<<dau[1]<<" pt:"<<dau[2]<<endl;
                     }
              }
       }
   }

   //cout<<" ********* finished catagorization *********"<<endl;

   // look at gen-muon distribution for each case 
   histo3 = h_Lep;
   for ( size_t i=0; i< mpa.size(); i++ ) {
       //cout<<"  genType = "<<mpa[i][3]<<endl; 
       if      (mpa[i][3] ==0 ) { histo3->Fill3a0(mpa[i][0],mpa[i][1],mpa[i][2]); }
       else if (mpa[i][3] ==1 ) { histo3->Fill3a1(mpa[i][0],mpa[i][1],mpa[i][2]); }
       else if (mpa[i][3] ==2 ) { histo3->Fill3a2(mpa[i][0],mpa[i][1],mpa[i][2]); }
       else if (mpa[i][3] ==3 ) { histo3->Fill3a3(mpa[i][0],mpa[i][1],mpa[i][2]); }
       else if (mpa[i][3] ==4 ) { histo3->Fill3a4(mpa[i][0],mpa[i][1],mpa[i][2]); }
   }

   // match the reco-muon
   std::vector<hfPos> rmpa = matchReco(mpa, recomuons);

   for ( size_t i=0; i< mpa.size(); i++ ) {
       double dr0 = 99;
       int k = -1;
       for ( size_t j=0; j< rmpa.size(); j++ ) {
           if ( rmpa[j][4]!= static_cast<double>(i) ) continue;
           double dh = mpa[i][0] - rmpa[j][0];  
           double df = mpa[i][1] - rmpa[j][1];
           double dr = sqrt( dh*dh + df*df );
           if ( dr < dr0 ) {
              k = static_cast<int>(j);
           } 
       }


       if ( k < 0 ) { 
          histo3->Fill3a5(mpa[i][0],mpa[i][1],mpa[i][2]); 
       } 
       else if (rmpa[k][3] == 0 && k >=0 ) { 
               histo3->Fill3b0(rmpa[k][0],rmpa[k][1],rmpa[k][2]); 
               histo3->Fill3d0(mpa[i][0],mpa[i][1],mpa[i][2]); 
       }
       else if (rmpa[k][3] == 1 && k >=0 ) { 
               histo3->Fill3b1(rmpa[k][0],rmpa[k][1],rmpa[k][2]); 
               histo3->Fill3d1(mpa[i][0],mpa[i][1],mpa[i][2]); 
       }
       else if (rmpa[k][3] == 2 && k >=0 ) { 
               histo3->Fill3b2(rmpa[k][0],rmpa[k][1],rmpa[k][2]); 
               histo3->Fill3d2(mpa[i][0],mpa[i][1],mpa[i][2]); 
       }
       else if (rmpa[k][3] == 3 && k >=0 ) { 
               histo3->Fill3b3(rmpa[k][0],rmpa[k][1],rmpa[k][2]); 
               histo3->Fill3d3(mpa[i][0],mpa[i][1],mpa[i][2]); 
       }
       else if (rmpa[k][3] == 4 && k >=0 ) { 
               histo3->Fill3b4(rmpa[k][0],rmpa[k][1],rmpa[k][2]); 
               histo3->Fill3d4(mpa[i][0],mpa[i][1],mpa[i][2]); 
       }
        
   }


   int nMuon =0;
   // 0:single like,  1:heavy flavour,  2:decay in flight,  3:others
   //int Mu[4] = {0};
   int motherID =0;
   for (std::vector<pat::Muon>::const_iterator mu_i = muons->begin(); mu_i != muons->end(); mu_i++)
   {
       //for (size_t j=0; j<(*mu_i).numberOfMothers(); ++j) {
       //cout<<" ---------------------------------- "<<endl;
       for (unsigned int j=0; j<(*mu_i).numberOfMothers(); j++) {
           const reco::Candidate *mom = (*mu_i).mother(static_cast<int>(j));
           motherID = mom->pdgId();
       //    cout<<" this muon's mother is = "<<motherID<<endl;        
       }
       //motherID = (*mu_i).mother(0)->pdgId();
       //cout <<" mu h = "<<(*mu_i).eta()<<" f = "<<(*mu_i).phi()<<" pt ="<<(*mu_i).pt()<<endl;

       if ( (*mu_i).pt() > 15.0 && fabs((*mu_i).eta()) < 2.1 ) {
          nMuon++; 
       }
       motherID = 0;
   }

   if ( pass ) {
      histo3 = h_Lep;
      for (std::vector<pat::Muon>::const_iterator mi = muons->begin(); mi != muons->end(); mi++){ 
          histo3->Fill3a( (*mi).pt(), (*mi).eta() );
      }

   }



}


std::vector<int> TtAnalysis::findGrandMa(int momId, double eta, double phi, 
                                         Handle<std::vector<reco::GenParticle> > genParticles) {

 double dR = 99.;
 std::vector<int> sources; 
 for (std::vector<reco::GenParticle>::const_iterator it = genParticles->begin(); it != genParticles->end(); it++ ){
     if ( (*it).pdgId()!= momId ) continue;
     double dEta = (*it).eta() - eta ;
     double dPhi = (*it).phi() - phi ;
     double dR1 = sqrt( dEta*dEta + dPhi*dPhi );

     if ( dR1 < dR ) {
        dR = dR1;
        sources.clear();
        for (size_t i=0; i< (*it).numberOfMothers(); i++) {
            const reco::Candidate *grandma = (*it).mother(i);
            sources.push_back(grandma->pdgId()); 
            //cout<<" W/Z : "<<(*it).pdgId()<<" from "<<grandma->pdgId()<<" h:"<<(*it).eta()<<" f:"<<(*it).phi()<<endl;
        }
     } 
  }
  return sources;

}

// return the daughters 
hfPos TtAnalysis::findDaughter(int dauId, int momId, double mom_eta, double mom_phi,
                                         Handle<std::vector<reco::GenParticle> > genParticles) {
 double dR = 99.;
 int mom_status = -99;
 int dau_status = -99;
 hfPos decayPos(4);
 for (std::vector<reco::GenParticle>::const_iterator it = genParticles->begin(); it != genParticles->end(); it++ ){
     // find the daughter candidate
     if ( (*it).pdgId()!= dauId && (*it).status() == 1 ) continue;
    
     // match their mom
     for (size_t i=0; i< (*it).numberOfMothers(); i++) {
         const reco::Candidate *mom = (*it).mother(i) ;
         if ( mom->pdgId() != momId ) continue;
	 double dEta = mom->eta() - mom_eta ;
	 double dPhi = mom->phi() - mom_phi ;
	 double dR1 = sqrt( dEta*dEta + dPhi*dPhi );
         if ( dR1 < dR ) {
            dR  = dR1;
	    decayPos[0] = (*it).eta();
	    decayPos[1] = (*it).phi();
	    decayPos[2] = (*it).pt();
	    decayPos[3] = -1;
	    mom_status = mom->status();
	    dau_status = (*it).status();
         }
     }
    
  }

  //cout <<" The "<<momId<<" (h:"<<mom_eta<<" f:"<<mom_phi <<" st:"<<mom_status<<")";
  //cout <<" decays to status("<<dau_status<<") "<<dauId<<" h:"<<decayPos[0]<<" f:"<<decayPos[1]<<endl;

  return decayPos;

} 

std::vector<hfPos> TtAnalysis::matchReco(std::vector<hfPos> mp,  
                                         Handle<std::vector<reco::Muon> > rmuon ) {

   std::vector<hfPos> rmpv; 
   rmpv.clear();
   for (std::vector<reco::Muon>::const_iterator it = rmuon->begin(); it != rmuon->end(); it++){
       double dR = 99.0;
       hfPos rmp(5);  
       rmp[3] = -1;
       rmp[4] = -1;
       for ( size_t i=0; i< mp.size(); i++ ) {
           double dEta = (*it).eta() - mp[i][0];
           double dPhi = (*it).phi() - mp[i][1];
           double dR1 = sqrt( dEta*dEta + dPhi*dPhi );
           if (dR1 < dR ) {
              dR = dR1;
              rmp[0] = (*it).eta();
              rmp[1] = (*it).phi();
              rmp[2] = (*it).pt();
              if (dR1 < 0.3) {
                 rmp[3] = mp[i][3];
                 rmp[4] = static_cast<double>(i);
              }
           } 
       }
       //cout<<"    This is type "<<rmp[3]<<" muon "<<endl; 
       rmpv.push_back(rmp);
   }
   return rmpv;
}

LorentzVector TtAnalysis::findW(LorentzVector qm1, LorentzVector qm2 ) {
     
     //cout<<" ------------------------------------------- "<<endl;
     exclude = false;
     double m1 = qm1.P();
     double m2 = qm2.P();
     /*
     double m1m2 = qm1.Px()*qm2.Px() + qm1.Py()*qm2.Py() + qm1.Pz()*qm2.Pz() ;
     //double massW = sqrt( (2.0*m1*m2) - (2.0*m1m2) ) ;
    // double angleqq = acos( m1m2/(m1*m2) ) ;
     cout<<" q1("<<m1<<") q2("<<m2<<") dP= "<< fabs(m1-m2) <<",open angle of qq = "<< angleqq << endl;
     cout<<" mass of W = "<< massW <<endl;
     if ( angleqq > 2.2 && (m1+m2)> 100. ) {
        cout<<" Candidate 1 !!! "<<endl;
     } 
     else if ( angleqq < 1.7 && (m1-m2)< 20. && (m1+m2) > 100.) {
        cout<<" Candidate 2 !!! "<<endl;
     }
     else if ( (m1+m2) > 100. && (m1+m2)< 1200. ) {
        cout<<" Candidate 3 !!! "<<endl;
     }
     else {

        exclude = true;
        if (  massW < 100. && massW > 60. ) {
          cout<<" NO GOOD @$#%@ " <<endl;
        } else {
          cout<<" *** exclude **** "<<endl;
        }
     } 
     */ 
     double xW = qm1.Px() + qm2.Px() ;
     double yW = qm1.Py() + qm2.Py() ;
     double zW = qm1.Pz() + qm2.Pz() ;
     double EW = m1 + m2 ;   
     LorentzVector mW = LorentzVector(xW,yW,zW,EW) ;
     //cout<<" pW: "<<xW<<","<<yW<<","<<zW<<","<<EW<<endl;
     //cout<<" mW: "<<mW.Px()<<","<<mW.Py()<<","<<mW.Pz()<<","<<mW.E()<<endl;

     return mW;
}

LorentzVector TtAnalysis::findTop(LorentzVector qm1, LorentzVector qm2 ) {
     
     //cout<<" ------------------ reco Top ------------------- "<<endl;
     double p1 = qm1.P();
     double p2 = qm2.P();
     //double p1p2 = qm1.Px()*qm2.Px() + qm1.Py()*qm2.Py() + qm1.Pz()*qm2.Pz() ;
     //double m1 = sqrt( (qm1.E()*qm1.E()) - (qm1.P()*qm1.P()) ) ;
     //double m2 = sqrt( (qm2.E()*qm2.E()) - (qm2.P()*qm2.P()) ) ;
     //double massT = sqrt( (m1*m1) + (m2*m2) + (2.0*p1*p2) - (2.0*p1p2) ) ;
     //double angleqq = acos( p1p2/(p1*p2) ) ;
     //cout<<" q1("<<p1<<") q2("<<p2<<") dP= "<< fabs(p1-p2) <<",open angle of Wb = "<< angleqq << endl;
     //cout<<" mass of Top = "<< massT <<endl;

     double xT = qm1.Px() + qm2.Px() ;
     double yT = qm1.Py() + qm2.Py() ;
     double zT = qm1.Pz() + qm2.Pz() ;
     double ET = p1 + p2 ;   
     LorentzVector mT = LorentzVector(xT,yT,zT,ET) ;
     //cout<<" pT: "<<xT<<","<<yT<<","<<zT<<","<<ET<<endl;
     //cout<<" mT: "<<mT.Px()<<","<<mT.Py()<<","<<mT.Pz()<<","<<mT.E()<<endl;

     return mT;
}

double TtAnalysis::NofJetConstituents( pat::Jet theJet ) {

    std::vector< const reco::Candidate* >  jc =  theJet.getJetConstituentsQuick();

    //for (size_t i=0; i < jc.size(); i++ ) {
    double sumE =0 ;
    for (size_t i=0; i < jc.size(); i++ ) {
        //const reco::Candidate* jj = dynamic_cast<const reco::Candidate*>( &*(jc[i]) );
        //cout<<" jet constituents "<< jc[i]->p4() ;
        //cout<<" h:"<<jc[i]->eta()<<" f:"<<jc[i]->phi()<<endl;
        sumE = sumE + jc[i]->energy() ;
    }
   
    /* 
    std::vector< reco::CandidateRef >      rf =  theJet.getJetConstituents();
    for (size_t i=0; i < rf.size(); i++ ) {
         cout<<" pdgId: "<< (*rf[i]).pdgId() <<endl;
    }
    */

    double sumP =0;
    edm::RefVector<reco::TrackCollection>  assTk = theJet.associatedTracks() ;
    for(size_t i=0; i < assTk.size(); i++ ) {
        sumP = sumP + (*assTk[i]).p() ;
        //cout <<" trk q:" <<(*assTk[i]).charge()<<" p4:  "<<(*assTk[i]).momentum() ;
        //cout <<" p: "<< (*assTk[i]).p() <<endl ;
    }
    // cout <<" jet E= "<< theJet.energy() <<" sumE= "<< sumE <<" scale-> "<< sumE/theJet.energy()<< endl;
    //cout <<" sum charged trk p= "<< sumP << endl;
    //cout <<" # of Constent "<< theJet.nConstituents() <<" # of charged trk: "<< assTk.size() <<endl;

    //float theJet.bDiscriminator();

    if ( assTk.size() > 0) {
       double nC = static_cast<double>( theJet.nConstituents() );
       double nT = static_cast<double>( assTk.size() ) ;
       //cout <<" ratio = "<< nC/nT <<endl;
       return nC/nT ;
    } else {
       return -1 ;
    }
}

double TtAnalysis::EoverH( pat::Jet theJet ) {

       float emE = theJet.emEnergyFraction() ;
       float hdE = theJet.energyFractionHadronic() ;
       double EovH = -2.0 ;
       if (hdE == 0.0 || (emE/hdE) >= 100.0 ) {
          EovH = 100.0;
       } 
       else {
          EovH = emE/hdE ;
       }
       
       return EovH;

}

std::vector<double> TtAnalysis::MuonEtCorrection( Handle<std::vector<pat::Muon> > mu ) {

     std::vector<double> ptcorr;
     ptcorr.clear();
     double pxy[4] ={0.0};
     for (std::vector<pat::Muon>::const_iterator u1 = mu->begin(); u1 != mu->end(); u1++)
     {
         if ( !(*u1).isGlobalMuon() ) continue;
         double Uem = ((*u1).getCalEnergy()).em;
         double Uhd = ((*u1).getCalEnergy()).had;
         double ex = (Uem+Uhd) * sin((*u1).theta()) * cos((*u1).phi()) ;
         double ey = (Uem+Uhd) * sin((*u1).theta()) * sin((*u1).phi()) ;
         pxy[0] += ((*u1).px() - ex) ;
         pxy[1] += ((*u1).py() - ey) ;
         pxy[2] += (*u1).px()  ;
         pxy[3] += (*u1).py()  ;
     }
     ptcorr.push_back(pxy[0]);
     ptcorr.push_back(pxy[1]);
     ptcorr.push_back(pxy[2]);
     ptcorr.push_back(pxy[3]);
     return ptcorr ;
}

// return 4 momentum of neutrino
LorentzVector TtAnalysis::findNeutrino( Handle<std::vector<reco::GenParticle> > genParticles ) {

   double vp[4] = {0.0};
   for (std::vector<reco::GenParticle>::const_iterator it = genParticles->begin(); it != genParticles->end(); it++ ){
       if ( abs((*it).pdgId()) != 24) continue;
       for (size_t v=0; v< (*it).numberOfDaughters(); ++v) {
           const reco::Candidate *dau = (*it).daughter(v) ;
           if( abs(dau->pdgId()) != 12 && abs(dau->pdgId()) != 14 ) continue;
	   //cout<<"daughter("<< dau->pdgId() <<") status:"<< dau->status() ;
	   //cout<<" p4:"<<dau->p4()<<endl;
           vp[0] +=  dau->px() ;
           vp[1] +=  dau->py() ;
           vp[2] +=  dau->pz() ;
           vp[3] +=  dau->p() ;
       }
   }

   LorentzVector vp4 = LorentzVector(vp[0],vp[1],vp[2],vp[3]);
   return vp4;
}

std::vector<double> TtAnalysis::CaloMET( Handle<CaloTowerCollection> calotowers ) {

   std::vector<double> caloInfo ;
   caloInfo.clear();
   double caloXY[2] = {0.0};
   for (CaloTowerCollection::const_iterator t1 = calotowers->begin(); t1 != calotowers->end(); t1++) {
       caloXY[0] += t1->et()*cos(t1->phi());
       caloXY[1] += t1->et()*sin(t1->phi());
   }
   double vsumEt = sqrt( caloXY[0]*caloXY[0] + caloXY[1]*caloXY[1] );
   double phi_sumEt = atan2(caloXY[1], caloXY[0]);
   caloInfo.push_back(caloXY[0]);
   caloInfo.push_back(caloXY[1]);
   caloInfo.push_back(vsumEt);
   caloInfo.push_back(phi_sumEt);

   return caloInfo;
}

//define this as a plug-in
DEFINE_FWK_MODULE(TtAnalysis);
